\documentclass{article}

\usepackage{fullpage}
\usepackage{url}

\title{Isabelle/HOL \\ \large CAS 701 Project Paper}

\author{Brooks MacLachlan, Nhan Thai}

\date{\today}

\begin{document}
	
\maketitle

\newpage
\section{Introduction}
Math and computing are the foundation of rapid development nowadays, but issues 
arise as their applications are getting bigger and
more complicated:

(1) In the field of mathematics, people often write proofs assuming
the readers can infer missing pieces of information and definitions,
otherwise it would be very tedious to repeat similar mathematics concepts
over and over. However, this approach gives rise to two problems. On one hand,
authors are prone to making mistakes because it is hard to
keep track of all the underlying assumptions. On the other hand, if readers
want to convince themselves that the proof is sound, they have to go over the entire
proof and verify it themselves.

(2) In the field of computing, writing tests alone is not
sufficient to show programs' correctness.
Also, it is unreasonable to write an algorithm on a computer then prove its
correctness on paper, for even if we can prove the idea is right, we have
no means to show the implementation is accurate.


Proof assistants have been developed to solve those problems,
and we believe it is inevitable that they will be a critical part of future mathematics and computing.
In this short paper we introduce Isabelle/HOL - one of the leading and most matured proof assistants.

Isabelle/HOL is both a functional programming language and a proof assistant.
Isabelle/HOL solves (1) because everything must is rigorously defined (e.g, 
natural numbers, induction principles, etc.),
and automatically checked for correctness, yet mathematicians do not need to 
write them all
because they are generated by Isabelle/HOL. For (2), we can write our 
algorithms in Isabelle/HOL since
it is a programming language, then we can write specifications and theorems for 
the algorithms and prove their
correctness also in Isabelle/HOL. What is remarkable here is that the proof for our program's correctness
can act as a certificate, which can be used (along with the program itself) in bigger programs and proofs.

Isabelle/HOL is shipped with an interactive development environment embedded in 
jEdit, called Isabelle/jEdit.
The instructions for downloading and installing can be found at Isabelle's 
homepage \cite{IsabelleWebsite}.


\section{Isabelle/HOL structure and principle}

Since Isabelle/HOL is a specialization of the more general language Isabelle,
there needs to be a distinction between Isabelle syntax and Isabelle/HOL
syntax. For example, language keywords like \textbf{theory} are part of the
general Isabelle syntax, whereas expressions of terms and types are part of
Isabelle/HOL. Thus, anything Isabelle/HOL-specific must be enclosed in
quotation marks. The use of quotation marks in this way is a major difference
between Isabelle/HOL and more traditional functional programming languages. In
the authors' experience, understanding when quotation marks were required was
one of the more confusing and unintuitive aspects of learning Isabelle/HOL.

The highest-level structure in Isabelle is called a theory, and can be declared 
with the keyword \textbf{theory} followed by the name of the theory. Each file 
should contain one theory, where the file name matches the name of the theory. 
The file extension for Isabelle files is ``.thy''. Theories can import other 
theories using the keyword \textbf{imports} followed by the names of the 
theories to import. The basic types, definitions, and theorems predefined in 
Isabelle/HOL are defined in a theory called ``Main'', which must be explicitly 
imported in other theories to use those predefined items. The body of a theory 
is a block containing definitions of (inductive) types, functions, theorems, and proofs.

Inductive types are defined using keyword \textbf{datatype}.
The syntax is described in \cite{IsabelleTutorial} section 2.3,
which is expected by most functional programmers and mathematicians.
Not only does Isabelle/HOL check if the inductive definition is valid, i.e not 
containing cyclic definitions,
it also provides common theorems associated with the inductive types such as 
distinctiveness, injectivity, and the induction principle.

The next building block is functions, whose syntax is described in \cite{IsabelleTutorial} section 2.3.
In Isabelle/HOL, we can define functions in terms of 3 principles: 
non-recursive with keyword \textbf{definition}, primitive recursive functions 
with keyword \textbf{primrec}, and
well-founded recursive functions with keyword \textbf{fun} if the termination 
proof can be automatically generated or with \textbf{function} if a 
user-supplied termination proof is required.
Isabelle/HOL will check if our provided functions comply with its definition 
principles, and inform us if the function is invalid.

Theorems and lemmas can be expressed in Isabelle/HOL using the keyword
\textbf{theorem} or \textbf{lemma} followed optionally by a name and colon then
mandatorily by a proposition in quotation
marks. A proposition is simply an expression of type \textit{bool}. Internally,
Isabelle/HOL does not distinguish between theorems and lemmas, so having both
keywords is simply to allow someone using Isabelle to organize their theory in
a more understandable way. Since they are treated identically by Isabelle, we
will collectively refer to theorems and lemmas as theorems from now on.

Any theorem must be followed by a proof. In general, there are two ways a proof
can be laid out in Isabelle/HOL. The basic way is as a sequence of ``apply''
steps, where each step consists of the keyword \textbf{apply} followed by the
name of the proof method to apply. Proofs in this style must end with the
keyword \textbf{done}. The other way to express a proof is in Isar. Isar is a
language built-in to Isabelle/HOL for expressing proofs in a more structured
and readable style, where intermediate steps are explicitly shown, with
subproofs. In either proof style, single-line proofs can be expressed with the
keyword \textbf{by} followed by the name of the proof method to use.

\section{Proof methods}

Induction is a very common proof method, so it is available in Isabelle/HOL. To
apply the induction method, one would call \textit{induction} followed by the 
name of the variable to induct on or induction rule to use. Whenever a function 
is defined recursively or a predicate inductively, an induction rule 
corresponding to that function or predicate is automatically created. These 
rules can be used in induction proofs to split the cases based on the rules in 
the definition of the function or predicate, instead of based on the general 
induction rule for an inductive type, which sometimes simplifies proofs. 
Checking the proof state in Isabelle/jEdit after 
applying induction will show that the proof has been split into a number of 
sub-goals based on the base case(s) and induction step(s). Each sub-goal then 
needs to be proven, which is often possible by an automated proof method.

One of the most straightforward automated proof methods available in 
Isabelle/HOL is called \textit{simp}, short for ``simplification''. This proof 
method repeatedly applies simplification rules to prove the theorem. A 
simplification rule is an equality where, if the left-hand side of the equality 
is encountered in an expression, it can be directly rewritten as the right-hand 
side. Each rule in a recursive function definition is automatically declared as 
a simplification rule, as are induction hypotheses in induction proofs. 
Theorems, however, are not. If one wishes to use a theorem as a simplification 
rule when applying \textit{simp}, they may write \textit{simp add:} followed by 
the theorem name to do so. Another option is to define the theorem as a 
simplification rule, which can be done by adding \textit{[simp]} between the 
theorem name and colon in the theorem definition.

Another automated proof method is \textit{auto}, which implicitly does
\textit{simp} but also does more, such as applying built-in introduction and 
elimination rules for adding or removing logical operators to an expression 
\cite{IsabelleManual}. 
For example, an implication introduction rule could be applied if there is an 
assumption, and it would bring the assumption into the expression as the 
precedent of an implication. Similarly to declaring a theorem as a 
simplification rule, a theorem can be declared as an introduction or 
elimination rule. However, it is up to the user of Isabelle/HOL to ensure that 
doing so will never lead to nontermination.

Some other common automated proof methods are \textit{arith} and 
\textit{blast}. \textit{arith} works for proving purely arithmetic expressions 
involving only numbers, variables, basic operators like addition, equality, and 
less than, and logical connectives. \textit{blast} is theoretically a complete 
proof method for first order logic. If a user is having trouble finding a proof 
method for a theorem, they can use the command \textbf{sledgehammer}, which 
will query external proof solvers and return Isabelle/HOL-compatible proof 
methods that can be directly copied and pasted into the proof. \textbf{try} is 
a command similar to \textbf{sledgehammer} except that it tries internal proof 
methods in addition to external ones.

\newpage

\nocite{*}

\bibliographystyle{plain}

\bibliography{References}

\end{document}